---
title: "Python per la finanza"
description: "Utilizzare Python in campo finanziario"
layout: post
toc: false
comments: true
categories: [python, finanza]
---

[Python](https://www.python.org) è per me diventato negli anni uno strumento indispensabile di lavoro, soprattutto quando i dati da gestire superano le capacità di Excel o per effettuare alcune analisi statistiche un po' più sofisticate del solito. Tuttavia, mi sono accorto che costruire un ambiente di lavoro efficace ed efficiente basato su Python non è sempre intuitivo, per cui proverò in questo post a condividere alcune delle cose che ho imparato nel tempo per giungere a una configurazione soddisfacente di questo importante strumento, soprattutto per chi lavora in ambito finanziario o ha comunque necessità di analizzare dei dati.

La distribuzione di Python più interessante per chi lavora con i dati (o fa *data science*, come si dice adesso) è sicuramente [Anaconda](https://www.anaconda.com/products/individual), che però installa di *default* fin troppe librerie scientifiche per i miei gusti. Esiste una versione *minimal* di `Anaconda`, [miniconda](https://docs.conda.io/en/latest/miniconda.html), che installa solo l'interprete del linguaggio e un set minimo di librerie per il funzionamento del *package manager*, lasciando all'utente la possibilità di installare poi solo gli ulteriori pacchetti effettivamente necessari per ciascun progetto. Qui però iniziano le difficoltà. Se da un lato `conda`, rispetto a `pip`, il *package manager* ufficiale di Python, permette una gestione delle librerie più agevole, dall'altro il numnero di pacchetti disponibili è ben inferiore. Per fortuna, un'ampia *community* si è fatta carico di ampliare la disponibilità di librerie sotto `conda` attraverso il canale `conda-forge`. Mischiare però le distribuzioni "ufficiali" di Anaconda con quelle di `conda-forge` è sconsigliabile e nel tempo rischia di corrompere i vari ambienti di lavoro di Python. Per questo ho recentemente scoperto con soddifazione [miniforge](https://github.com/conda-forge/miniforge), un clone di `miniconda` che scarica direttamente i pacchetti di Python dal canale della *community* di `conda-forge`[^1]. Alla fine, quindi, sto usando con soddisfazione da alcuni mesi questa distribuzione, con impostazioni identiche tra i vari dispositivi che utilizzo in modo da avere ambienti di lavoro intercambiabili.

Passando alle librerie vere e proprie, la prima cosa da installare, secondo me, è la triade [numpy](https://numpy.org/>) - [pandas](https://pandas.pydata.org/) - [matplotlib](https://matplotlib.org/). Altamente integrati tra loro, questi tre pacchetti soddisfano tutte le esigenze di analisi e visualizzazione dei dati, sostituendo più che degnamente gli enormi fogli Excel con centinaia di collegamenti che vanno velocemente fuori controllo. A questa configurazione base si possono poi aggiungere numerose altre librerie più specializzate, tra cui, ad esempio, [scipy](https://www.scipy.org/) per le procedure di ottimizzazione o [scikit-learn](https://scikit-learn.org/stable/) per classificazione e regressione (o - più pomposamente - per il *machine learning*).

Tutto questo può essere gestito tramite un normale *editor* di testo o l'interprete interattivo di Python, ma è probabilmente più comodo fare le prime analisi di un progetto attraverso un *notebook*, un'applicazione *web* che consente di mescolare codice, risultati, visualizzazioni e testi in un unico documento. Qui entra in gioco [jupyter](https://jupyter.org/), progetto *open source* di *notebook* multi-linguaggio, che nell'ultima versione - `JupyterLab` - integra anche un terminale e vari *plugin* che lo rendono un vero e proprio ambiente *web* interattivo di sviluppo. Sebbene i *notebook*, estremamente versatili proprio per la capacità di integrare codice, testo e grafici in un unico documento, possano essere strumenti decisamente sofisticati in grado di generare un prodotto finito molto elegante, si prestano anche bene per le prime analisi esplorative e per costruire veloci prototipi di progetto, grazie all'immediatezza con cui in poche righe di codice si può caricare una tabella di dati, elaborarla e produrre qualche grafico a corredo.

Il problema dei *notebook* è che si prestano a uno stile di [programmazione imperativo](https://it.wikipedia.org/wiki/Programmazione_imperativa) che rischia di produrre documenti "pasticciati" in caso di progetti più complessi e strutturati. Per questi ultimi, sono però disponibili strumenti che permettono di creare con relativa facilità delle vere e proprie applicazioni *web* in cui risulta più semplice separare parametri e algoritmi e strutturare in modo più funzionale il codice. Tra questi strumenti, citerei in particolare [Streamlit](https://streamlit.io/) che ho recentemente utilizzato per costruire una *dashboard* nella quale riunire tutti i *task* quotidiani in modo da avere un vero e proprio pannello di controllo delle attività ricorrenti nella mia giornata lavorativa. Quello che mi ha sorpreso di `Streamlit` è l'assoluta facilità con cui è stato possibile integrare elementi interattivi nel codice per costruire pagine *web* dinamiche; inoltre - ma questa è una caratteristica che condivide con molti altri pacchetti - come sia stato possibile costruire delle vere e proprie *web app* solo con Python[^2].

Ecco, in sintesi questo è il mio ambiente di lavoro dietro lo schermo. Peraltro, io sono un tipo curioso e ho provato diversi strumenti in questi anni, prima di arrivare a una configurazione più o meno stabile che ho cercato qui di descrivere. E non è detto che non troverò qualcosa di interessante anche domani, per cui cambierò qualcosa e avrò una scusa per tornare a parlarne. 

[^1]: Anche se in realtà lo stesso risultato si può ottenere in :code:`miniconda` settando il canale :code:`conda-forge` per primo.
[^2]: Ovviamente, dietro c'è anche tanto Javascript, ma se ne occupa direttamente :code:`Streamlit` o chi per lui.
 
