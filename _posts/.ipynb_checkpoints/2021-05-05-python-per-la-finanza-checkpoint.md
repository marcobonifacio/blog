.. title: Python per la finanza
.. slug: python-per-la-finanza
.. date: 2021-05-03 17:35:12 UTC+02:00
.. tags: python, conda, numpy, pandas, matplotlib, jupyter, streamlit
.. category: programmazione
.. link: 
.. description: 
.. type: text

`Python <https://www.python.org>`_ è per me diventato negli anni uno strumento indispensabile di lavoro, soprattutto quando i dati da gestire superano le capacità di Excel o per effettuare alcune analisi statistiche un po' più sofisticate del solito. Tuttavia, mi sono accorto che costruire un ambiente di lavoro efficace ed efficiente basato su Python non è sempre intuitivo, per cui proverò in questo post a condividere alcune delle cose che ho imparato nel tempo per giungere a una configurazione soddisfacente di questo importante strumento, soprattutto per chi lavora in ambito finanziario o ha comunque necessità di analizzare dei dati.

.. TEASER_END

La distribuzione di Python più interessante per chi lavora con i dati (o fa *data science*, come si dice adesso) è sicuramente `Anaconda <https://www.anaconda.com/products/individual>`_, che però installa di *default* fin troppe librerie scientifiche per i miei gusti. Esiste una versione *minimal* di :code:`Anaconda`, `miniconda <https://docs.conda.io/en/latest/miniconda.html>`_, che installa solo l'interprete del linguaggio e un set minimo di librerie per il funzionamento del *package manager*, lasciando all'utente la possibilità di installare poi solo gli ulteriori pacchetti effettivamente necessari per ciascun progetto. Qui però iniziano le difficoltà. Se da un lato :code:`conda`, rispetto a :code:`pip`, il *package manager* ufficiale di Python, permette una gestione delle librerie più agevole, dall'altro il numnero di pacchetti disponibili è ben inferiore. Per fortuna, un'ampia *community* si è fatta carico di ampliare la disponibilità di librerie sotto :code:`conda` attraverso il canale :code:`conda-forge`. Mischiare però le distribuzioni "ufficiali" di Anaconda con quelle di :code:`conda-forge` è sconsigliabile e nel tempo rischia di corrompere i vari ambienti di lavoro di Python. Per questo ho recentemente scoperto con soddifazione `miniforge <https://github.com/conda-forge/miniforge>`_, un clone di :code:`miniconda` che scarica direttamente i pacchetti di Python dal canale della *community* di :code:`conda-forge` [#]_. Alla fine, quindi, sto usando con soddisfazione da alcuni mesi questa distribuzione, con impostazioni identiche tra i vari dispositivi che utilizzo in modo da avere ambienti di lavoro intercambiabili.

Passando alle librerie vere e proprie, la prima cosa da installare, secondo me, è la triade `numpy <https://numpy.org/>`_ - `pandas <https://pandas.pydata.org/>`_ - `matplotlib <https://matplotlib.org/>`_. Altamente integrati tra loro, questi tre pacchetti soddisfano tutte le esigenze di analisi e visualizzazione dei dati, sostituendo più che degnamente gli enormi fogli Excel con centinaia di collegamenti che vanno velocemente fuori controllo. A questa configurazione base si possono poi aggiungere numerose altre librerie più specializzate, tra cui, ad esempio, `scipy <https://www.scipy.org/>`_ per le procedure di ottimizzazione o `scikit-learn <https://scikit-learn.org/stable/>`_ per classificazione e regressione (o - più pomposamente - per il *machine learning*).

Tutto questo può essere gestito tramite un normale *editor* di testo o l'interprete interattivo di Python, ma è probabilmente più comodo fare le prime analisi di un progetto attraverso un *notebook*, un'applicazione *web* che consente di mescolare codice, risultati, visualizzazioni e testi in un unico documento. Qui entra in gioco `jupyter <https://jupyter.org/>`_, progetto *open source* di *notebook* multi-linguaggio, che nell'ultima versione - :code:`JupyterLab` - integra anche un terminale e vari *plugin* che lo rendono un vero e proprio ambiente *web* interattivo di sviluppo. Sebbene i *notebook*, estremamente versatili proprio per la capacità di integrare codice, testo e grafici in un unico documento, possano essere strumenti decisamente sofisticati in grado di generare un prodotto finito molto elegante, si prestano anche bene per le prime analisi esplorative e per costruire veloci prototipi di progetto, grazie all'immediatezza con cui in poche righe di codice si può caricare una tabella di dati, elaborarla e produrre qualche grafico a corredo.

Il problema dei *notebook* è che si prestano a uno stile di `programmazione imperativo <https://it.wikipedia.org/wiki/Programmazione_imperativa>`_ che rischia di produrre documenti "pasticciati" in caso di progetti più complessi e strutturati. Per questi ultimi, sono però disponibili strumenti che permettono di creare con relativa facilità delle vere e proprie applicazioni *web* in cui risulta più semplice separare parametri e algoritmi e strutturare in modo più funzionale il codice. Tra questi strumenti, citerei in particolare `Streamlit <https://streamlit.io/>`_ che ho recentemente utilizzato per costruire una *dashboard* nella quale riunire tutti i *task* quotidiani in modo da avere un vero e proprio pannello di controllo delle attività ricorrenti nella mia giornata lavorativa. Quello che mi ha sorpreso di :code:`Streamlit` è l'assoluta facilità con cui è stato possibile integrare elementi interattivi nel codice per costruire pagine *web* dinamiche; inoltre - ma questa è una caratteristica che condivide con molti altri pacchetti - come sia stato possibile costruire delle vere e proprie *web app* solo con Python [#]_.

Ecco, in sintesi questo è il mio ambiente di lavoro dietro lo schermo. Peraltro, io sono un tipo curioso e ho provato diversi strumenti in questi anni, prima di arrivare a una configurazione più o meno stabile che ho cercato qui di descrivere. E non è detto che non troverò qualcosa di interessante anche domani, per cui cambierò qualcosa e avrò una scusa per tornare a parlarne. 

.. [#] Anche se in realtà lo stesso risultato si può ottenere in :code:`miniconda` settando il canale :code:`conda-forge` per primo.
.. [#] Ovviamente, dietro c'è anche tanto Javascript, ma se ne occupa direttamente :code:`Streamlit` o chi per lui.
 
